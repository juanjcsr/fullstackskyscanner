# Implementation:

I downloaded the zip file from the Geektastic page but I could not make it work.
It had outdated versions of the client libraries that referenced a SASS package that is not published any more. I found that the Github Skyscanner's repo had an updated version, so I used it.

I started by working on the backend. First I started by analyzing what kind of 
response the SkyScanner API gave me.  Having a collection of objects in different keys meant that I had to join them by their relationships:

from:
```
-Itineraries
-Legs
-Segments
```

to:

```
Itineraries 
  |
  |---Legs
       |
       |----Segments
```
And also join each object with their associated data (Places, Agents, Carriers).

I grouped each collection by their Id to make them easier to search (like a hash table, constant time access) and then map them to their corresponding collection.

Then I started working on the frontend. I started creating Components that matched the API response but I found it was hard to match the required design. I started then creating Components from the top-down: 

Itineraries -> Cards -> Legs -> Segments

with a ItineraryContainer that holds the state and makes the API requests.

I then created a SearchForm that gets the required params for the API (Origin, Destination, Dates, Number of passengers and flight class). Inside this form, the dates and the Origin and Destination places inputs are disabled but their are defaulted to Edinburgh to London, from next Monday (March 25) to next Tuesday (March 26).

While I was working with the search form, I discovered the API had **pagination**. I implemented it by having the user select which kind of search they want:

* Paginated: It returns the first page of the search.  When the user clicks the "See More", it returns the next page only when the API returns there are no pending results (according to the [API documentation](https://skyscanner.github.io/slate/#polling-the-results)). The user has to keep clicking the button until the server responds with no pending data to get the next pages.
* Full results: It returns the whole search by long polling the API. It is slower but it has the whole dataset without further user interaction.

To get the project ready for deployment and production I made the backend serve the static files generated by the client `npm run build` command. 

I then created the testing environment (made sure the testing and lint commands passed), created the deploy environment (Heroku) and the Dockerfile.

The solution is deployed in this URL: https://lit-refuge-41130.herokuapp.com


### Q) What libraries did you add to the frontend? What are they used for?

I found the whole Backpack Components from SkyScanner where useful to prototype the UX and to develop it quickly.

The libraries I used were:

* bpk-component-accordion" : For the collapsible **Stops** section in the cards if the selected flight has more than 1 stop.
* bpk-component-button": For all the buttons
* bpk-component-card": This library is used for a single Itinerary
* bpk-component-grid"
* bpk-component-icon"
* bpk-component-input"
* bpk-component-label"
* bpk-component-select"
* bpk-component-spinner"
* backpack-react-scripts"
* bpk-component-text"

For the backend I used lodash to iterate in a more functional way the API dataset. Also I used **pm2** to make easier to monitor and restart the server process inside a Docker container.
 
### Q) What is the command to start the server?

(Default) `APIKEY=<key> npm run server`

(Docker, exposes 8080 port) `docker build -t juanjcsr/skyscanner . && docker run --rm -p 8080:8080 -e APIKEY=[THEAPIKEY] juanjcsr/skyscanner`

---

# General:

### Q) How long, in hours, did you spend on the test?

About 3 hours daily at nigth from Saturday to Wednesday.  I had more free time on Monday where I could spent almost 6 hours working non-stop :)  

### Q) If you had more time, what further improvements or new features would you add?

I wanted to implement the long-polling process in the client to free the connection. This way the server can scale up better because it does not have to keep the connection open.  However I had difficult time implementing it in the client because the API does not return the max number of pages. I tried to implement a infinite scroll to query the next page but it started to consume too much development time.

I would also add more tests. I added snapshot tests but I wanted to add state tests.

### Q) Which parts are you most proud of? And why?

The data transformation from the API. While it is not the most efficient way to group and join a dataset, I love working with complex datasets and I think the implementation I did works for the frontend.  Also I am happy I could create an implementation for a paginated search because it is faster to get results instead of waiting for the full search results :)

### Q) Which parts did you spend the most time with? What did you find most difficult?

The dataset format and the paginated search.  Also, I need more CSS skills to better design the application.

### Q) How did you find the test overall? If you have any suggestions on how we can improve the test or our API, we'd love to hear them.

I really loved the test! It was easy to understand the problem and the base project had enough room to start working while also giving enough pointers in the problem direction.  I found the Backpack documentation was really useful, but I would add more examples to the components, specially for the HOC libraries (Infinite Scroll).

